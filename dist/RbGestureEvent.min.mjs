/*!
* rb-gesture-event 1.0.0
* Â©2024 Nor.E & Null -
* Released under the MIT license
* https://null-nore.github.io/RbGestureEvent/
*/let t=!1;const e=Symbol.for("RBEventList"),n=Symbol.for("RBLongtouch"),o=Symbol.for("RBCallbackMapping");class i{move=!1;firstMove=!1;velocity=[0,0];displacement=[0,0];location=[0,0];startLocation=[0,0];velocityTimeOut=setTimeout((()=>{}),1)}class r{time=Date.now();eventType="";scale=1;deltaAngle=0;midPoint=[0,0];midDisplacement=[0,0];maxPoint=0;clickCount=0;lastClickLocation=[0,0];lastClickTime=Date.now();isRotate=!1;firstRotate=!1;isPinch=!1;firstPinch=!1;startLength=0;startAngle=0;startTime=Date.now();pointers=new Map;triggerPointer=new i;pointerCount=0;originEvent=new PointerEvent("none")}const a={press:(t,e,n)=>"down"==t.eventType&&"down"==n,release:(t,e,n)=>"up"==t.eventType&&"up"==n,click:(t,e,n)=>!(!a.release(t,e,n)||0!=t.pointerCount)&&t.clickCount>=1,doubleclick:(t,e,n)=>!!a.click(t,e,n)&&(t.clickCount%2==0&&t.clickCount>0),longtouch:(t,e,n)=>{if("longtouch"==n){const e=Date.now()-t.startTime>=500,n=1==t.maxPoint,o=!t.triggerPointer.move;return e&&n&&o}return!1},dragstart:(t,e,n)=>{if("move"==n||"up"==n){const n=1==t.pointerCount,o=1==e.pointerCount,i=t.triggerPointer.firstMove,r=t.triggerPointer.move;return n&&(i||!o)&&r}return!1},dragmove:(t,e,n)=>{if("move"==n){const e=1==t.pointerCount,n=t.triggerPointer.firstMove,o=t.triggerPointer.move;return e&&o&&!n}return!1},dragend:(t,e,n)=>{if("up"==n||"down"==n){const n=1==e.pointerCount,o=1!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}},dragcancel:(t,e,n)=>{if("cancel"==n||"down"==n){const n=1==e.pointerCount,o=1!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}return!1},dragleft:(t,e,n)=>{if(a.dragmove(t,e,n)){return t.triggerPointer.displacement[0]<0}return!1},dragright:(t,e,n)=>{if(a.dragmove(t,e,n)){return t.triggerPointer.displacement[0]>0}return!1},dragup:(t,e,n)=>{if(a.dragmove(t,e,n)){return t.triggerPointer.displacement[1]<0}return!1},dragdown:(t,e,n)=>{if(a.dragmove(t,e,n)){return t.triggerPointer.displacement[1]>0}return!1},doubledragstart:(t,e,n)=>{if("move"==n||"down"==n){const n=2==t.pointerCount,o=2==e.pointerCount,i=t.triggerPointer.firstMove||e.triggerPointer.firstMove,r=t.triggerPointer.move||e.triggerPointer.move;return n&&(i||!o)&&r}return!1},doubledragmove:(t,e,n)=>{if("move"==n){const n=2==t.pointerCount,o=t.triggerPointer.firstMove||e.triggerPointer.firstMove,i=t.triggerPointer.move||e.triggerPointer.move;return n&&i&&!o}return!1},doubledragend:(t,e,n)=>{if("up"==n||"down"==n){const n=1==e.pointerCount,o=1!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}return!1},doubledragcancel:(t,e,n)=>{if("cancel"==n||"down"==n){const n=1==e.pointerCount,o=1!=t.pointerCount,i=t.triggerPointer.move;return n&&i&&o}return!1},swipeleft:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=n<-c.config.threshold,a=n<0&&Math.abs(n)>Math.abs(o),s=t.triggerPointer.move,l=t.triggerPointer.velocity[0]<-c.config.swipeVelocityThreshold;return i&&s&&a&&r&&l}return!1},swiperight:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=n>c.config.threshold,a=n>0&&Math.abs(n)>Math.abs(o),s=t.triggerPointer.move,l=t.triggerPointer.velocity[0]>c.config.swipeVelocityThreshold;return i&&s&&a&&r&&l}return!1},swipeup:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=o<-c.config.threshold,a=o<0&&Math.abs(o)>Math.abs(n),s=t.triggerPointer.move,l=t.triggerPointer.velocity[1]<-c.config.swipeVelocityThreshold;return i&&s&&a&&r&&l}return!1},swipedown:(t,e,n)=>{if("up"==n){const[n,o]=t.triggerPointer.displacement,i=1==e.maxPoint,r=o>c.config.threshold,a=o>0&&Math.abs(o)>Math.abs(n),s=t.triggerPointer.move,l=t.triggerPointer.velocity[1]>c.config.swipeVelocityThreshold;return i&&s&&a&&r&&l}return!1},pinchstart:(t,e,n)=>{if("move"==n){const e=t.isPinch,n=t.firstPinch;return e&&n}return!1},pinchmove:(t,e,n)=>{if("move"==n){const e=t.isPinch,n=t.firstPinch;return e&&!n}return!1},pinchend:(t,e,n)=>{if("up"==n){const n=e.isPinch,o=!t.isPinch;return n&&o}return!1},pinchcancel:(t,e,n)=>{if("cancel"==n){const n=e.isPinch,o=!t.isPinch;return n&&o}return!1},pinchin:(t,e,n)=>{if(a.pinchmove(t,e,n)){return t.scale<1}return!1},pinchout:(t,e,n)=>{if(a.pinchmove(t,e,n)){return t.scale>1}return!1},rotatestart:(t,e,n)=>{if("move"==n){const e=t.isRotate,n=t.firstRotate;return e&&n}return!1},rotatemove:(t,e,n)=>{if("move"==n){const e=t.isRotate,n=t.firstRotate;return e&&!n}return!1},rotateend:(t,e,n)=>{if("up"==n){const n=e.isRotate,o=!t.isRotate;return n&&o}return!1},rotatecancel:(t,e,n)=>{if("cancel"==n){const n=e.isRotate,o=!t.isRotate;return n&&o}return!1}};class c{static eventState=new r;static lastEventState=new r;static outEventState=new r;static condition={};static config={threshold:5,swipeVelocityThreshold:.3,clickThreshold:500,longtouchThreshold:500,angleThreshold:5,scaleThreshold:.05};constructor(){document.addEventListener("DOMContentLoaded",(()=>{[["pointerdown",c.pointerdown],["pointermove",c.pointermove],["pointerup",c.pointerup],["pointercancel",c.pointerCancel]].forEach((t=>window.addEventListener(t[0],t[1],!0)))}))}static setDebug(e){t=e,t&&console.log("%cRbGestureEvent - debug mode on, version: 1.0.0","\n         color: white;\n         background-color: #333333; \n         font-weight: bold;\n         text-shadow: 0 0 5px white;\n         padding: 0.5em;\n         border-left: 5px solid #ff0000;\n         border-right: 5px solid #ff0000;\n         ")}static setConfig(t){Object.assign(c.config,t)}static cloneStateTo(t){const e=c.eventState.originEvent;c.eventState.originEvent=null,c[t]=structuredClone(c.eventState),c[t].originEvent=e,c.eventState.originEvent=e}static copyStateToLast(){this.cloneStateTo("lastEventState"),c.lastEventState.time=Date.now()}static copyState(){this.cloneStateTo("outEventState")}static updateEventState(t,e,n){const o=t.pointerId;e.originEvent=t,e.time=Date.now(),e.eventType=n,e.triggerPointer=e.pointers.get(o)}static initializeTwoPointerState(t){const e=[...t.pointers.values()].slice(0,2).map((t=>[t.location[0],t.location[1]]));t.startLength=c.eDistance(...e),t.startAngle=c.refAngle(...e),t.midPoint=c.midPoint(...e)}static updateTwoPointerState(t){const[e,n]=[...t.pointers.values()].slice(0,2),{location:o,displacement:i}=e,{location:r,displacement:a}=n,s=c.eDistance(o,r),l=c.refAngle(o,r);t.scale=s/t.startLength,t.deltaAngle=l-t.startAngle,t.midPoint=c.midPoint(o,r),t.midDisplacement=c.midPoint(i,a)}static updateVelocity(t,e,n){clearTimeout(t.velocityTimeOut),t.velocityTimeOut=setTimeout((()=>{t.velocity=[0,0]}),100);const o=Date.now()-e.time;t.velocity=[(t.location[0]-e.pointers.get(n).location[0])/o,(t.location[1]-e.pointers.get(n).location[1])/o]}static pointerdown=t=>{c.copyStateToLast();const e=c.eventState;c.updateEventState(t,e,"down");const n=t.pointerId;e.pointers.set(n,{move:!1,firstMove:!1,velocity:[0,0],displacement:[0,0],location:[t.clientX,t.clientY],startLocation:[t.clientX,t.clientY],velocityTimeOut:setTimeout((()=>{}),100)}),e.triggerPointer=e.pointers.get(n),e.pointerCount++,e.maxPoint=Math.max(e.maxPoint,e.pointerCount),1==e.pointerCount&&(e.startTime=Date.now()),2==e.pointerCount&&c.initializeTwoPointerState(e),c.copyState()};static pointermove=t=>{c.copyStateToLast();const e=c.eventState,n=c.lastEventState;if(e.pointerCount<1)return;const o=t.pointerId,i=e.pointers.get(o),r=[t.clientX-i.startLocation[0],t.clientY-i.startLocation[1]];Math.hypot(...r)>c.config.threshold&&(c.updateEventState(t,e,"move"),i.firstMove=!i.move,i.move=!0,i.location=[t.clientX,t.clientY],i.displacement=r,c.updateVelocity(i,n,o),e.pointerCount>=2&&c.updateTwoPointerState(e),e.firstRotate=!e.isRotate,e.isRotate=Math.abs(e.deltaAngle)>=c.config.angleThreshold||e.isRotate,e.firstPinch=!e.isPinch,e.isPinch=Math.abs(1-e.scale)>=c.config.scaleThreshold||e.isPinch,c.copyState())};static pointerup=t=>{c.copyStateToLast();const e=c.eventState;c.updateEventState(t,e,"up"),e.pointers.delete(t.pointerId),e.pointerCount--,1==e.maxPoint&&e.startTime-e.time<500&&!e.triggerPointer.move?(c.eDistance(e.triggerPointer.location,e.lastClickLocation)<20&&Date.now()-e.lastClickTime<500?e.clickCount++:e.clickCount=1,e.lastClickTime=Date.now(),e.lastClickLocation=[...e.triggerPointer.location]):e.clickCount=0,e.pointerCount<2&&(e.isRotate=!1,e.isPinch=!1,e.deltaAngle=0,e.scale=1),0==e.pointerCount&&(e.maxPoint=0),c.copyState()};static pointerCancel=t=>{c.copyStateToLast();const e=c.eventState;c.updateEventState(t,e,"cancel"),e.pointers.delete(t.pointerId),e.pointerCount--,e.pointerCount<2&&(e.isRotate=!1,e.isPinch=!1,e.deltaAngle=0,e.scale=1),0==e.pointerCount&&(e.maxPoint=0),c.copyState()};static registerEventListener(n,i,r){if(null==a[i])throw new Error(`event type ${i} not found`);let s;if(n[e]||(n[e]={},n.addEventListener("pointerdown",c.downDispatch),n.addEventListener("pointermove",c.moveDispatch),n.addEventListener("pointerup",c.upDispatch),n.addEventListener("pointerout",c.outDispatch),n.addEventListener("pointercancel",c.cancelDispatch)),n[e][i]||(n[e][i]=[]),""!=r.name)if(n[o]){if(n[o].has(r)){t&&console.warn("callback already registered\n",r);const e=n[o].get(r);s=e.boundcallback,e.count+=1}}else n[o]=new Map,s=r.bind(n),n[o].set(r,{boundcallback:s,count:1});else s=r.bind(n);n[e][i].push(s),t&&(console.log(`register event: ${i} on`,n),console.log("eventList:",n[e]))}static cancelEventListener(n,i,r){if(t&&console.log(`cancel event: ${i} on`,n),!n[o].has(r))throw t&&console.error("callback not found\n","eventList:",n[e],"\n","callback:",r),new Error("callback not found");{const a=n[e][i];let{boundcallback:s,count:l}=n[o].get(r);const p=a.indexOf(s);a.splice(p,1),l-=1,0==l&&n[o].delete(r),0==n[e][i].length&&(delete n[e][i],0==Object.keys(n[e]).length&&(delete n[e],n.removeEventListener("pointerdown",c.downDispatch),n.removeEventListener("pointermove",c.moveDispatch),n.removeEventListener("pointerup",c.upDispatch),n.removeEventListener("pointerout",c.outDispatch),n.removeEventListener("pointercancel",c.cancelDispatch))),t&&console.log("eventList:",n[e])}}static setCondition(e,n){a[e]&&t&&console.warn(`event type ${e} already exists, will be overwritten`),a[e]=n}static removeCondition(t){if(!a[t])throw new Error(`event type ${t} not found`);delete a[t]}static downDispatch(){c.dispatchEvent(this,"down"),1==c.eventState.pointerCount?this[n]=setTimeout((()=>{c.longtouchDispatch(this)}),c.config.longtouchThreshold):this[n]&&clearTimeout(this[n])}static longtouchDispatch(t){c.dispatchEvent(t,"longtouch")}static moveDispatch(){c.eventState.pointerCount>=1&&c.dispatchEvent(this,"move")}static upDispatch(){c.dispatchEvent(this,"up"),clearTimeout(this[n])}static outDispatch(){clearTimeout(this[n])}static cancelDispatch(){c.dispatchEvent(this,"cancel"),clearTimeout(this[n])}static dispatchEvent(t,n){for(const o of Object.keys(t[e]))a[o](c.eventState,c.lastEventState,n)&&t[e][o].forEach((t=>t(c.outEventState)))}static eDistance=([t,e],[n,o])=>{const[i,r]=[t-n,e-o];return Math.hypot(i,r)};static refAngle=([t,e],[n,o])=>{const[i,r]=[t-n,e-o];return Math.atan2(r,i)/Math.PI*180};static midPoint=([t,e],[n,o])=>[(t+n)/2,(e+o)/2]}new c;